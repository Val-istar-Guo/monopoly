// NOTE Node babel source map support
require('source-map-support').install();

require('app-module-path').addPath(process.cwd());
// NOTE Javascript require hook
require('babel-register')({
  presets: ['es2015'],
  plugins: [
    'add-module-exports',
    'transform-object-rest-spread',
    'transform-export-extensions',
  ],
});

const fs = require('fs');
const path = require('path');
const chalk = require('chalk');

const webpack = require('webpack');
const MemoryFileSystem = require('memory-fs');
const webpackMiddleware = require('koa-webpack');
const HTML_FILE_NAME = require('../contants/html-file-name');

const vueServerRender = require('../server/middleware/vue-server-render');
const server = require('../server/server.js');

const PORT = process.env.PORT || 8080;
const HOST = process.env.HOST || '0.0.0.0';


let renderer = null;
let bundleJson = null;
let isWriteTemplate = false;


/**
 * NOTE devConfig used to make template
 *      and make webpack dev middleware
 */
const devConfig = require('../webpack/webpack.config.dev');
const devCompiler = webpack(devConfig);

/**
 * NOTE Webpack hook event to write html file template
 *      due to server render
 */
devCompiler.plugin('emit', ({ assets }, cb) => {
  const filePath = Object.keys(assets).find(key => key.includes(HTML_FILE_NAME));

  if (filePath) {
    const data = assets[filePath].source();
    fs.writeFileSync(path.resolve(__dirname, filePath), data);
    isWriteTemplate = true;

    if (bundleJson) {
      renderer = vueServerRender(bundleJson);
    }
  }

  cb();
});


/**
 * NOTE ssrConfig used to make vue ssr bundle json file.
 *      It is must after devConfig because replay file template
 */
const {
  default: ssrConfig,
  ssrFileName } = require('../webpack/webpack.config.ssr');

const ssrComplier = webpack(ssrConfig);
const mfs = new MemoryFileSystem();
ssrComplier.outputFileSystem = mfs;

// NOTE read bundle generated by vue-ssr-webpack-plugin
ssrComplier.watch({}, (err, data) => {
  if (err) throw err;
  const stats = data.toJson();

  stats.errors.forEach(err => console.log(chalk.red.bold(err)));
  stats.warnings.forEach(warn => console.log(chalk.yellow(warn)));

  const bundlePath = path.join(ssrConfig.output.path, ssrFileName);
  bundleJson = JSON.parse(mfs.readFileSync(bundlePath, 'utf-8'));

  if (isWriteTemplate) {
    renderer = vueServerRender(bundleJson);
  }
});

// Set Server
server
  .use(webpackMiddleware({
    compiler: devCompiler,
    dev: {
      publicPath: devConfig.output.publicPath,
      stats: {
        colors: true,
        chunks: false,
      },
    },
  }))
  .use(async (ctx, next) => {
    if (renderer === null) {
      ctx.body = '⌛️ WAITTING FOR COMPLIATION! REFRESH IN A MOMENT';
    } else {
      await next();
    }
  })
  .use(async (ctx, next) => {
    await renderer(ctx, next);
  })
  .listen(PORT, HOST);

// server
//   .use(convert(devMiddleware(devCompiler, {
//     publicPath: devConfig.output.publicPath,
//     stats: {
//       colors: true,
//       chunks: false,
//     },
//   })))
//   .use(convert(hotMiddleware(devCompiler)))
//   .use(async (ctx, next) => {
//     const context = ctx;
//     if (renderer === null) {
//       context.body = '⌛️ WAITTING FOR COMPLIATION! REFRESH IN A MOMENT';
//     } else {
//       await next();
//     }
//   })
//   .use(async (ctx, next) => {
//     await renderer(ctx, next);
//   })
//   .listen(PORT, HOST);

console.log(chalk.green(`🌏 Server Start at ${HOST}:${PORT}`));
if (renderer === null) {
  console.log(chalk.green('⌛️ Waiting For Cpmpliation!'));
}
